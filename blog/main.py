from typing import List, Union
from fastapi import FastAPI, Depends, status, Response
import uvicorn
from sqlalchemy.orm import Session

import schemas
import models
from database import engine, SessionLocal
from hashing import Hash

models.Base.metadata.create_all(engine)

app = FastAPI()
hash = Hash()

def get_db():
    db = SessionLocal()
    try :
        yield db
    finally :
        db.close()


@app.post(
    '/blog', 
    status_code=status.HTTP_201_CREATED,
    tags = ["Blog"]
)
def create(
    request:schemas.Blog, 
    db: Session = Depends(get_db)
):
    new_blog = models.Blog(title = request.title, body = request.body)
    db.add(new_blog)
    db.commit()
    db.refresh(new_blog)   # get stuff like id generated by the database
    return new_blog


@app.get(
    '/blog',
    response_model=List[schemas.ShowBlog],
    tags = ["Blog"]
)
def all_blogs(
    db: Session = Depends(get_db)
):
    blogs = db.query(models.Blog).all()
    return blogs


@app.get(
    '/blog/{id}',
    status_code=200,
    response_model=schemas.ShowBlog,
    tags = ["Blog"]
)
def get_single_blog(
    id:int, response : Response, 
    db: Session = Depends(get_db)
):
    blog = db.query(models.Blog).filter(models.Blog.id==id).first()
    if not blog :
        response.status_code = status.HTTP_404_NOT_FOUND
        return {
            "message" : f"Blog with id {id} not available"
        }
    return blog


@app.delete(
    '/blog/{id}', 
    status_code=status.HTTP_204_NO_CONTENT, 
    tags = ["Blog"]
)
def destroy(
    id:int, 
    response : Response, 
    db: Session = Depends(get_db)
):
    blog = db.query(models.Blog).filter(models.Blog.id==id).first()
    if not blog :
        response.status_code = status.HTTP_404_NOT_FOUND
        return {
            "message" : f"Blog with id {id} not available"
        }
    db.query(models.Blog).filter(models.Blog.id==id).delete()
    db.commit()


@app.put(
    '/blog/{id}', 
    status_code=status.HTTP_202_ACCEPTED, 
    tags = ["Blog"]
)
def edit(
    id:int, 
    request : schemas.Blog, 
    response : Response, 
    db: Session = Depends(get_db)
):
    blogs = db.query(models.Blog).filter(models.Blog.id==id)
    if(len(blogs.all())==0):
        response.status_code = status.HTTP_404_NOT_FOUND
        return {
            "message" : f"Blog with id {id} not available"
        }
    blogs.update(
        {
            "title" : request.title, 
            "body" : request.body
        }, 
        synchronize_session=False
    )
    db.commit()
    return {
        "message" : "Blog Updated"
    }




@app.post(
    '/user',
    status_code=status.HTTP_201_CREATED,
    response_model=schemas.ShowUser,
    tags = ["User"]
)
def create_user(
    request : schemas.User,
    db: Session = Depends(get_db)
):
    hashed_password = hash.bcrypt(request.password)
    request.password = hashed_password
    new_user = models.User(**request.__dict__)
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    return new_user


@app.get(
    '/user/{id}',
    response_model=Union[
        schemas.ShowUser,
        schemas.MessageSchema
    ],
    tags = ["User"]
)
def get_user(
    id : int,
    response : Response,
    db: Session = Depends(get_db)
):
    user = db.query(models.User).filter(models.User.id==id)
    if not user.first() :
        response.status_code = status.HTTP_404_NOT_FOUND
        return {
            "message" : f"User {id} not found"
        }
    return user.first()


if __name__=="__main__":
    uvicorn.run(app, host="127.0.0.1", port="8000")